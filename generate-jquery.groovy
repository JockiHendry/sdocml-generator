import groovy.xml.MarkupBuilder
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.Paths

def cli = new CliBuilder()
cli.usage = 'generate-jquery [options]'
cli.help('print this message')
cli.url(args:1, argName: 'url', optionalArg: true, 'retrieve XML API documentation from this URL. Default URL is http://api.jquery.com/resources/api.api')
cli.file(args:1, argName: 'file', optionalArg: false, 'retrieve XML API documentation from XML file')
cli.output(args: 1, argName: 'file', optionalArg: false, required: true, 'output JsDoc to this file')

def options = cli.parse(args)
if (!options) return
if (options.help) {
    cli.usage()
    return
}

def api

if (options.file) {

    Path xmlFile = Paths.get(options.file)
    if (!Files.exists(xmlFile)) {
        println "Error: Can't find $xmlFile"
        return
    }
    println "Reading XML from file: $xmlFile"
    api = new XmlSlurper().parse(xmlFile.toFile())

} else if (options.url) {

    String url = options.getOptionValue('url', 'http://api.jquery.com/resources/api.xml')
    println "Reading XML from url: $url"
    String xmlText = new URL(url).getText()
    api = new XmlSlurper().parseText(xmlText)

} else {

    println "error: invalid options"
    cli.usage()
    return

}

def convertMethod(jsdoc, args) {
    String name = args.@name
    if (name.contains('.')) name = name[name.lastIndexOf('.')+1..-1]
    args.signature.each { signature ->
        jsdoc.method(name: name, scope: 'instance') {
            description(args.desc)
            'return-types' {
                'return-type'(type: args.@return)
            }
            parameters {
                signature.argument.each { argument ->
                    parameter(name: argument.@name, usage: argument.@optional=='true'?'optional':'required', type: argument.@type) {
                        description(argument.desc)
                    }
                }
            }
            examples {
                example(args.example)
            }
        }
    }
}

def convertConstructor(jsdoc, args) {
    args.signature.each { signature ->
        jsdoc.constructor(scope: 'instance') {
            description(args.desc)
            'return-types' {
                'return-type'(type: 'jQuery')
            }
            parameters {
                signature.argument.each { argument ->
                    parameter(name: argument.@name, usage: argument.@optional=='true'?'optional':'required', type: argument.@type) {
                        description(argument.desc)
                    }
                }
            }
            examples {
                example(args.example)
            }
        }
    }
}

def convertProperty(jsdoc, args, simple = false) {
    String name = args.@name
    if (name.contains('.')) name = name[name.lastIndexOf('.')+1..-1]
    jsdoc.property(name: name, type: args.@return, scope: 'instance') {
        description(args.desc)
        examples {
            example(args.example)
        }
    }
}

def writer = new FileWriter(options.output)
def jsdoc = new MarkupBuilder(writer)
jsdoc.mkp.xmlDeclaration(version: '1.0')
jsdoc.mkp.comment 'Generated by sdocml-generator (http://github.com/JockiHendry)'


def types = ['jQuery': [:]]

// Find types
api.entries.entry.findAll { it.@name.toString().contains('.') }.each {
    String name = it.@name
    String typeName = name[0..name.lastIndexOf('.')-1]
    types[typeName] = [:]
}

jsdoc.javascript {
    aliases {
        alias(name: '$', type: 'jQuery')
    }

    // Generate types
    types.keySet().each { type ->
        'class'(type: type) {
            def entries
            if (type == 'jQuery') {
                constructors {
                    api.entries.entry.findAll {
                        it.@type == 'method' && !it.@name.toString().contains('.') && it.@name == 'jQuery'
                    }.each {
                        convertConstructor(jsdoc, it)
                    }
                }
                properties {
                    // Normal jQuery properties
                    api.entries.entry.findAll { it.@type=='property' && !it.@name.toString().contains('.') }.each {
                        convertProperty(jsdoc, it)
                    }
                    // Static jQuery properties
                    api.entries.entry.findAll { it.@type=='property' &&
                            (it.@name.toString().split(/\./).length==2 && it.@name.toString().startsWith('jQuery.')) }.each {

                        convertProperty(jsdoc, it)
                    }
                    // Pseudo objects
                    List founds = []
                    api.entries.entry.findAll {
                        it.@name.toString().split(/\./).length == 3 && it.@name.toString().startsWith('jQuery.')
                    }.each {
                        String name = it.@name.toString()
                        String pseudoName = name.split(/\./)[1]
                        if (founds.contains(pseudoName)) {
                            return
                        } else {
                            founds << pseudoName
                        }
                        String pseudoType = name[0..name.lastIndexOf('.')-1]
                        property(name: pseudoName, type: pseudoType, scope: 'instance') {
                            description(pseudoName)
                        }
                    }
                }
                methods {
                    // Normal jQuery methods
                    api.entries.entry.findAll { it.@type=='method' && !it.@name.toString().contains('.') }.each {
                        convertMethod(jsdoc, it)
                    }
                    // Static jQuery methods
                    api.entries.entry.findAll { it.@type=='method' &&
                            (it.@name.toString().split(/\./).length==2 && it.@name.toString().startsWith('jQuery.')) }.each {
                        convertMethod(jsdoc, it)
                    }
                }
            } else {
                properties {
                    api.entries.entry.findAll { it.@type=='property' && it.@name.toString().startsWith("${type}.")}.each {
                        convertProperty(jsdoc, it)
                    }
                }
                methods {
                    api.entries.entry.findAll { it.@type=='method' && it.@name.toString().startsWith("${type}.")}.each {
                        convertMethod(jsdoc, it)
                    }
                }
            }
        }
    }

}

println "File ${options.output} has been generated!"
